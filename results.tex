\section{Results}

\begin{figure}
  \begin{centering}
  \includegraphics[width=.8\columnwidth]{mesh}
  \caption{\label{fig:mesh} Initial coarse mesh (a),
  	half refined mesh (b) and refined mesh (c). The coarse mesh
	and refined mesh were used in the initial calculations, the latter one
	in case of \emph{p}-adaptivity (including HP\_ANISO\_P). The half-refined mesh was
	used later to optimize the \emph{hp}-adaptive refinement solutions.}
  \end{centering}
\end{figure}
Calculation for all the refinement modes were performed
in both single-mesh and multi-mesh configurations. 
The following numerical results were recorded for each 
refinement mode: converged relative error, cumulative CPU
time, and the problem size in terms of number
of degrees of freedoms (NDOFs) at each time step. 
Two types of initial meshes were used --- in case of only \emph{p}-adaptivity,
more refined mesh was used (Fig.~\ref{fig:mesh}~(c)) to ensure
the error convergence.
When the element size refinement
was also enabled (all \emph{h}/\emph{hp} refinement modes), very coarse initial mesh
was used (see Fig.~\ref{fig:mesh}~(a)) to let the adaptivity
algorithm find the most optimal mesh. So coarse initial mesh might not be
suitable for all the practical applications, as will be demonstrated in the
end of this section, however, it provides a good insight into the
adaptivity performance of Hermes.
In both cases, the initial mesh was loaded at each time step of the
calculation.

\begin{figure}
  \begin{centering}
  \includegraphics[width=.75\columnwidth]{cphi}
  \caption{\label{fig:cphi} Concentration $C$
  and voltage $\phi$ at two different time steps
  (HP\_ANISO adaptivity was used). This is a 2D solution shown
  as in 3D, where the height indicates the values of $C$ and $\phi$.}
  \end{centering}
\end{figure}
Example of the solution at $t=0.7\ s$ and $t=3.0\ s$ 
with refinement mode HP\_ANISO is shown
in Fig.~\ref{fig:cphi}. The time $t=0.7\ s$ was chosen because
by that time, some ionic migration has already taken place, i.e.
concentration gradient near the $\partial\Omega_1$ and
$\partial\Omega_3$ has formed. The automatic mesh refinements
at different time steps are clearly visible in the figure --- especially
near the top boundary, where the concentration gradient is
moving in time (as was also seen in Fig.~\ref{fig:comsol-conc-volt}).

The following subsections provide a detailed comparison of
the different refinement modes and try to estimate the most suitable
one for the given problem.

\subsection{Optimal refinement modes}

\begin{figure}
  \begin{centering}
  \includegraphics[width=\columnwidth]{singlemulti_dof}
  \caption{\label{fig:singlemultidof} NDOFs in case 
  of single-mesh and multi-mesh solutions with HP\_ISO
  and HP\_ANISO refinements. (Notice log Y scale)}
  \end{centering}
\end{figure}
\begin{figure}
  \begin{centering}
  \includegraphics[width=\columnwidth]{singlemulti_cpu}
  \caption{\label{fig:singlemulticpu} CPU times in case
  of single-mesh and multi-mesh solutions with HP\_ISO
  and HP\_ANISO refinements. (Notice log Y scale)}
  \end{centering}
\end{figure}
\begin{figure}
  \begin{centering}
  \includegraphics[width=.75\columnwidth]{poly}
  \caption{\label{fig:poly} Polynomial degree space
  for $C$ and $\phi$ at $t=0.7\ s$ The color indicates
  the maximum polynomial degree of the corresponding element.}
  \end{centering}
\end{figure}

Running the simulation with different refinement modes 
and meshes showed that the multi-mesh configuration generally results in
a smaller problem, faster calculation, and better or similar error convergence
compared to the single-mesh configuration.
This is well illustrated in Fig.~\ref{fig:singlemultidof} 
and Fig.~\ref{fig:singlemulticpu}.
The result can be understood from Fig.~\ref{fig:comsol-conc-volt} --- in the boundary
regions $\partial \Omega_1$ and $\partial\Omega_3$ the concentration gradient
is greater than voltage gradient, namely $\nabla C >> \nabla \phi$. Therefore
refining the mesh for both variables is not reasonable in terms of
number of degrees of freedom. For instance,
the solution space with corresponding mesh in case of
HP\_ANISO at $t=0.7\ s$ is shown in Fig.~\ref{fig:cphi}. The corresponding polynomial
degree space is shown in Fig.~\ref{fig:poly}. Notice that the adaptive algorithm
has increased the maximum polynomial degree for $C$ space to 7, however,
at the same time, the maximum polynomial degree for the $\phi$ space is one. Furthermore,
the mesh is significantly more refined for $C$.
For most cases using the multi-mesh results in similar or better CPU time, i.e.
multi-mesh takes less computational resources. Only excpetion was HP\_ANISO\_H 
refinement mode for which the single mesh configuration resulted slightly faster
calculation time. 
Based on the results, only multi-mesh configurations will be considered
in the following comparisons.

\begin{figure}
  \begin{centering}
  \includegraphics[width=\columnwidth]{isoaniso_dof}
  \caption{\label{fig:isoanisodof} NDOFs in case 
  of multi-mesh solutions with H\_ISO, H\_ANISO,
  HP\_ISO, HP\_ANISO, and single-mesh solution with HP\_ANISO\_H
  refinement modes. (Notice log Y scale)}
  \end{centering}
\end{figure}
\begin{figure}
  \begin{centering}
  \includegraphics[width=\columnwidth]{isoaniso_cpu}
  \caption{\label{fig:isoanisocpu} CPU times in case 
  of multi-mesh solutions with H\_ISO, H\_ANISO,
  HP\_ISO, HP\_ANISO, and single-mesh solution with HP\_ANISO\_H
  refinement modes. (notice log Y scale)}
  \end{centering}
\end{figure}
\begin{figure}
  \begin{centering}
  \includegraphics[width=\columnwidth]{isoanisop_dof}
  \caption{\label{fig:isoanisopdof} NDOFs in case 
  of multi-mesh solutions with P\_ISO, P\_ANISO, and
  HP\_ANISO\_P refinement modes.}
  \end{centering}
\end{figure}
\begin{figure}
  \begin{centering}
  \includegraphics[width=\columnwidth]{isoanisop_cpu}
  \caption{\label{fig:isoanisopcpu} CPU times in case 
  of multi-mesh solutions with P\_ISO, P\_ANISO, and
  HP\_ANISO\_P refinement modes.}
  \end{centering}
\end{figure}
To narrow down the list of refinement modes for the given problem, first the
isotropic and anisotropic adaptivities were compared. The \emph{p}-adaptivity
modes were compared separately as they used more refined mesh (Fig.~\ref{fig:mesh}~(c)).
Fig.~\ref{fig:isoanisodof} and Fig.~\ref{fig:isoanisocpu} show the comparison
of H\_ISO, H\_ANISO, HP\_ISO, HP\_ANISO, and HP\_ANISO\_H modes in terms of CPU time
and problem size.
Fig.~\ref{fig:isoanisopdof} and Fig.~\ref{fig:isoanisopcpu} show the similar
comparsion for the P\_ISO, P\_ANISO, and HP\_ANISO\_P modes.
It can be clearly seen that the anisotropic refinement modes result in a reasonable problem
size and the problems solve within a reasonable calculation time. It is interesting
to note that HP\_ANISO results in the smallest problem size. Also, in
\emph{p}-adaptivity group, HP\_ANISO\_P results in the smallest problem size
at each time step, whereas P\_ISO and P\_ANISO have a very largy problem size
during the first time steps of the solution.
Here the term ``reasonable problem size''
means that the number of degrees of freedom in time converges
to so that $N_{dof}<500$, and the term ``reasonable calculation time''
means that the calculation (step $\tau=0.01\ s$, physical
time $t_{end}=3.0\ s$) time $t$ on a givem system was $t<500\ s$.
Although these parameters are empirical, they serve as an upper limit, given
that the most refinement modes give significantly smaller results:
$t<<500\ s$ and $N_{dof} << 500$.

\subsection{Quantitative analysis of the refinement modes}

Based on the results in the previous subsection, H\_ANISO, HP\_ANISO,
and HP\_ANISO\_H from the \emph{hp/h}-adaptivity group and HP\_ANISO\_P
from \emph{p}-adaptivity group will be compared
in terms of problem size and cumulative CPU time. 
In all of the cases, the relative 
error at each time step remained below
the threshold which were set to $e_{th}=0.5\%$ between the coarse mesh
and fine mesh solutions, therefore the error-time plot will not be considered.

\begin{figure}
  \begin{centering}
  \includegraphics[width=\columnwidth]{cpu}
  \caption{\label{fig:cpu} Comparative CPU time for different refinement modes.}
  \end{centering}
\end{figure}

\begin{figure}
  \begin{centering}
  \includegraphics[width=\columnwidth]{dof}
  \caption{\label{fig:dof} Comparative NDOFs at each time step for 
  different refinement modes.}
  \end{centering}
\end{figure}

Fig.~\ref{fig:cpu} shows the cumulative CPU time for different refinement 
modes at each time step. All the calculations were done on the same computer.
Here we see that HP\_ANISO\_H and HP\_ANISO require the most
resources which can be understood from the fact that these 
refinement modes have the largest number of 
candidates (see Section.~\ref{sec:model}) from which the refinement method is chosen.
At the same time, HP\_ANISO\_P is the fastest among all the other refinement modes.
Fig.~\ref{fig:dof} shows the NDOFs at each time step.
It can be seen that the HP\_ANISO results in the 
smallest problem size --- $N_{dof} \approx 125$. 
All the other refinement modes result in a 
problem size of approximately ($N_{dof} \approx 250$). So we have
two notable refinement modes --- HP\_ANISO\_P because of the fast
solution, and HP\_ANISO because of the small problem size. In the following
subsection, optimization of those two modes will be considered.


\subsection{Optimizations of HP\_ANISO and HP\_ANISO\_P refinement modes}

\begin{figure}
  \begin{centering}
  \includegraphics[width=\columnwidth]{refined_cpu}
  \caption{\label{fig:refined-cpu} Cumulative CPU time for HP\_ANISO and HP\_ANISO\_P
  with different initial meshes.}
  \end{centering}
\end{figure}

\begin{figure}
  \begin{centering}
  \includegraphics[width=\columnwidth]{refined_dof}
  \caption{\label{fig:refined-dof} NDOFs at each time step for
  HP\_ANISO and HP\_ANISO\_P with different meshes.}
  \end{centering}
\end{figure}

So far we have seen that HP\_ANISO results in the smallest problem size, but requires
quite a lot CPU time compared to HP\_ANISO\_P that is the fastest.
When it comes to a large domain or 3D modeling the problem
size becomes the most important factor. Therefore, we consider HP\_ANISO the most
suitable refinement mode to the given problem. Thus some ways to optimize the time
factor will be considered. The desirable output would be HP\_ANISO problem size
close to HP\_ANISO\_P CPU time. One way to optimize the problem
is to choose somewhat more refined initial mesh. Other way one could think
to optimize the problem would be to change
the refinement frequency during the solving process. Recall that up to this point,
the initial mesh has been loaded in the beginning of each time step. True,
by employing the optimizations, we already must know something about the problem
and its solution beforehand. However, it could still be practial when solving a real problem
in a large domain.

The problem size and CPU time with HP\_ANISO
and HP\_ANISO\_P adaptivities on more refined initial mesh (see Fig.~\ref{fig:mesh}~(c))
compared to the coarse initial mesh (Fig.~\ref{fig:mesh}~(a)) and 
HP\_ANISO\_P solution is shown in Fig.~\ref{fig:refined-cpu} and Fig.~\ref{fig:refined-dof}.
By using initially more refined mesh, the problem solving time
can be reduced in case of HP\_ANISO, at the same time, the problem size increases.
In this situation, HP\_ANISO\_P and HP\_ANISO perform equally well.

\begin{figure}
  \begin{centering}
  \includegraphics[width=\columnwidth]{unreffreq_dof}
  \caption{\label{fig:unreffreq-dof} NDOFs at each time step for
  HP\_ANISO and HP\_ANISO\_P with mesh unrefinement at each time step and at over each
  	time step after first $0.5\ s$ physical solution time.}
  \end{centering}
\end{figure}
The next proposed optimization involved changing the unrefinement frequency.
It is known that the concentration gradient $\nabla C$ changes the most in the initial phase
of the calculation, therefore, the unrefinement after each time step was performed
until $t=0.5\ s$ (physical time). After that, the
unrefinement was performed in $\Delta t = 0.10\ s$ interval.
However, this optimization did not result in a stable solution, i.e. the problem size 
does not remain steady, but starts to oscillate depending on the unrefinement
frequency. This is shown in 
Fig.~\ref{fig:unreffreq-dof}. 

Therefore varying the unrefinement frequency will
not likely result in desired results in real applications for given system of equation.
At the same time, by varying a mesh size, optimal initial mesh could be found
for both HP\_ANISO and HP\_ANISO\_P refinement modes.
	 
\subsection{More general results}
\begin{figure}
  \begin{centering}
  \includegraphics[width=.75\columnwidth]{cphiorders}
  \caption{\label{fig:cphi-orders} Solutions $C$ and $\phi$
  and corresponding polynomial degrees of the elements at
  $t=0.7\ s$. HP\_ANISO refinement mode was used. The height
  in the solution graphs indicates the value.}
  \end{centering}
\end{figure}

Based on the results, cation concentration and voltage was calculated
for different boundary conditions.
For instance, when voltage is applied as follows
\begin{equation}
  \phi_{\Omega_1}=0.5\frac{x}{width_{\Omega_1}}+0.5,
\end{equation}
the concentration gradient $\nabla C$ and the voltage gradient $\nabla \phi$ are no
longer effectively 1D.
The calculated $C$ and $\phi$ in $\Omega$ and corresponding meshes and polynomial
degrees of the elements are shown in Fig.~\ref{fig:cphi-orders}.
HP\_ANISO refinement mode was used. Notice that the solution
is different to the one in Fig.~\ref{fig:cphi} and the adapted mesh and the
polynomial degrees are also more complicated than in Fig.~\ref{fig:poly}.
It must be noted that in case of non uniform boundary conditions which
results in 2D problem, refined initial mesh was more efficient to use.

\emph{
PAVEL: Should I try to include the similar solution from comsol and do
some comparison here? I got this idea just before commiting the final
draft to you?}
